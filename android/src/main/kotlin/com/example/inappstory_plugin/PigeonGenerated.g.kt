// Autogenerated from Pigeon (v22.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class StoryTypeDto(val raw: Int) {
  COMMON(0),
  UGC(1);

  companion object {
    fun ofRaw(raw: Int): StoryTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class SourceTypeDto(val raw: Int) {
  SINGLE(0),
  ONBOARDING(1),
  LIST(2),
  FAVORITE(3),
  STACK(4);

  companion object {
    fun ofRaw(raw: Int): SourceTypeDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class ClickActionDto(val raw: Int) {
  BUTTON(0),
  SWIPE(1),
  GAME(2),
  DEEPLINK(3);

  companion object {
    fun ofRaw(raw: Int): ClickActionDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class Position(val raw: Int) {
  TOP_LEFT(0),
  TOP_RIGHT(1),
  BOTTOM_LEFT(2),
  BOTTOM_RIGHT(3);

  companion object {
    fun ofRaw(raw: Int): Position? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StoryAPIDataDto (
  val id: Long,
  val storyData: StoryDataDto,
  val imageFilePath: String? = null,
  val videoFilePath: String? = null,
  val hasAudio: Boolean,
  val title: String,
  val titleColor: String,
  val backgroundColor: String,
  val opened: Boolean,
  val aspectRatio: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StoryAPIDataDto {
      val id = pigeonVar_list[0] as Long
      val storyData = pigeonVar_list[1] as StoryDataDto
      val imageFilePath = pigeonVar_list[2] as String?
      val videoFilePath = pigeonVar_list[3] as String?
      val hasAudio = pigeonVar_list[4] as Boolean
      val title = pigeonVar_list[5] as String
      val titleColor = pigeonVar_list[6] as String
      val backgroundColor = pigeonVar_list[7] as String
      val opened = pigeonVar_list[8] as Boolean
      val aspectRatio = pigeonVar_list[9] as Double
      return StoryAPIDataDto(id, storyData, imageFilePath, videoFilePath, hasAudio, title, titleColor, backgroundColor, opened, aspectRatio)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      storyData,
      imageFilePath,
      videoFilePath,
      hasAudio,
      title,
      titleColor,
      backgroundColor,
      opened,
      aspectRatio,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StoryDataDto (
  val id: Long,
  val title: String? = null,
  val tags: String? = null,
  val feed: String? = null,
  val sourceType: SourceTypeDto? = null,
  val slidesCount: Long,
  val storyType: StoryTypeDto? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StoryDataDto {
      val id = pigeonVar_list[0] as Long
      val title = pigeonVar_list[1] as String?
      val tags = pigeonVar_list[2] as String?
      val feed = pigeonVar_list[3] as String?
      val sourceType = pigeonVar_list[4] as SourceTypeDto?
      val slidesCount = pigeonVar_list[5] as Long
      val storyType = pigeonVar_list[6] as StoryTypeDto?
      return StoryDataDto(id, title, tags, feed, sourceType, slidesCount, storyType)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      title,
      tags,
      feed,
      sourceType,
      slidesCount,
      storyType,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SlideDataDto (
  val story: StoryDataDto,
  val index: Long,
  val payload: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SlideDataDto {
      val story = pigeonVar_list[0] as StoryDataDto
      val index = pigeonVar_list[1] as Long
      val payload = pigeonVar_list[2] as String?
      return SlideDataDto(story, index, payload)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      story,
      index,
      payload,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StoryFavoriteItemAPIDataDto (
  val id: Long,
  val imageFilePath: String? = null,
  val backgroundColor: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): StoryFavoriteItemAPIDataDto {
      val id = pigeonVar_list[0] as Long
      val imageFilePath = pigeonVar_list[1] as String?
      val backgroundColor = pigeonVar_list[2] as String
      return StoryFavoriteItemAPIDataDto(id, imageFilePath, backgroundColor)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      imageFilePath,
      backgroundColor,
    )
  }
}
private open class PigeonGeneratedPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          StoryTypeDto.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          SourceTypeDto.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          ClickActionDto.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          Position.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StoryAPIDataDto.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StoryDataDto.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SlideDataDto.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StoryFavoriteItemAPIDataDto.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is StoryTypeDto -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is SourceTypeDto -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is ClickActionDto -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is Position -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is StoryAPIDataDto -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is StoryDataDto -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is SlideDataDto -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is StoryFavoriteItemAPIDataDto -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface InappstorySdkModuleHostApi {
  fun initWith(apiKey: String, userID: String, sendStatistics: Boolean, callback: (Result<Unit>) -> Unit)
  fun setPlaceholders(newPlaceholders: Map<String, String>)
  fun setTags(tags: List<String>)

  companion object {
    /** The codec used by InappstorySdkModuleHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `InappstorySdkModuleHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: InappstorySdkModuleHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.initWith$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val apiKeyArg = args[0] as String
            val userIDArg = args[1] as String
            val sendStatisticsArg = args[2] as Boolean
            api.initWith(apiKeyArg, userIDArg, sendStatisticsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.setPlaceholders$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val newPlaceholdersArg = args[0] as Map<String, String>
            val wrapped: List<Any?> = try {
              api.setPlaceholders(newPlaceholdersArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.setTags$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tagsArg = args[0] as List<String>
            val wrapped: List<Any?> = try {
              api.setTags(tagsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface IASStoryListHostApi {
  fun load(feed: String)
  fun openStoryReader(storyId: Long)
  fun showFavoriteItem()
  fun updateVisiblePreviews(storyIds: List<Long>)

  companion object {
    /** The codec used by IASStoryListHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `IASStoryListHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: IASStoryListHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.load$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val feedArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.load(feedArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.openStoryReader$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val storyIdArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.openStoryReader(storyIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.showFavoriteItem$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.showFavoriteItem()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.updateVisiblePreviews$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val storyIdsArg = args[0] as List<Long>
            val wrapped: List<Any?> = try {
              api.updateVisiblePreviews(storyIdsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class InAppStoryAPIListSubscriberFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by InAppStoryAPIListSubscriberFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun updateStoryData(var1Arg: StoryAPIDataDto, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoryData$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(var1Arg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun updateStoriesData(listArg: List<StoryAPIDataDto>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoriesData$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(listArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun updateFavoriteStoriesData(listArg: List<StoryFavoriteItemAPIDataDto>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateFavoriteStoriesData$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(listArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class ErrorCallbackFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by ErrorCallbackFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun loadListError(feedArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadListError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(feedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun loadOnboardingError(feedArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadOnboardingError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(feedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun loadSingleError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadSingleError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun cacheError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.cacheError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun readerError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.readerError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun emptyLinkError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.emptyLinkError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun sessionError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.sessionError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun noConnection(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.noConnection$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class CallToActionCallbackFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by CallToActionCallbackFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun callToAction(slideDataArg: SlideDataDto?, urlArg: String?, clickActionArg: ClickActionDto?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.CallToActionCallbackFlutterApi.callToAction$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(slideDataArg, urlArg, clickActionArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface AppearanceManagerHostApi {
  fun setHasLike(value: Boolean)
  fun setHasFavorites(value: Boolean)
  fun setHasShare(value: Boolean)
  fun setClosePosition(position: Position)
  fun setTimerGradientEnable(isEnabled: Boolean)
  fun getTimerGradientEnable(): Boolean
  fun setTimerGradient(colors: List<Long>, locations: List<Double>)
  fun setReaderBackgroundColor(color: Long)
  fun setReaderCornerRadius(radius: Long)

  companion object {
    /** The codec used by AppearanceManagerHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `AppearanceManagerHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: AppearanceManagerHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasLike$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setHasLike(valueArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasFavorites$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setHasFavorites(valueArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasShare$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setHasShare(valueArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setClosePosition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val positionArg = args[0] as Position
            val wrapped: List<Any?> = try {
              api.setClosePosition(positionArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradientEnable$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val isEnabledArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setTimerGradientEnable(isEnabledArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.getTimerGradientEnable$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getTimerGradientEnable())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradient$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val colorsArg = args[0] as List<Long>
            val locationsArg = args[1] as List<Double>
            val wrapped: List<Any?> = try {
              api.setTimerGradient(colorsArg, locationsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderBackgroundColor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val colorArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.setReaderBackgroundColor(colorArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderCornerRadius$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val radiusArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.setReaderCornerRadius(radiusArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface IASSingleStoryHostApi {
  fun showOnce(storyId: Long)
  fun show(storyId: Long, slide: Long)

  companion object {
    /** The codec used by IASSingleStoryHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `IASSingleStoryHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: IASSingleStoryHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.showOnce$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val storyIdArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.showOnce(storyIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.show$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val storyIdArg = args[0] as Long
            val slideArg = args[1] as Long
            val wrapped: List<Any?> = try {
              api.show(storyIdArg, slideArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class IShowStoryOnceCallbackFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by IShowStoryOnceCallbackFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun onShow(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.onShow$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.onError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun alreadyShown(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.alreadyShown$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class SingleLoadCallbackFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by SingleLoadCallbackFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun singleLoad(storyDataArg: StoryDataDto, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.SingleLoadCallbackFlutterApi.singleLoad$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(storyDataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface IASOnboardingsHostApi {
  /**
   * [feed] by default == "onboarding"
   * [limit] has to be set greater than 0 (can be set as any big number if limits is unnecessary)
   */
  fun show(limit: Long, feed: String, tags: List<String>)

  companion object {
    /** The codec used by IASOnboardingsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `IASOnboardingsHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: IASOnboardingsHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.inappstory_plugin.IASOnboardingsHostApi.show$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val limitArg = args[0] as Long
            val feedArg = args[1] as String
            val tagsArg = args[2] as List<String>
            val wrapped: List<Any?> = try {
              api.show(limitArg, feedArg, tagsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class OnboardingLoadCallbackFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by OnboardingLoadCallbackFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  fun onboardingLoad(countArg: Long, feedArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.inappstory_plugin.OnboardingLoadCallbackFlutterApi.onboardingLoad$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(countArg, feedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
