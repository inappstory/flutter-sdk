// Autogenerated from Pigeon (v22.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum StoryTypeDto: Int {
  case cOMMON = 0
  case uGC = 1
}

enum SourceTypeDto: Int {
  case sINGLE = 0
  case oNBOARDING = 1
  case lIST = 2
  case fAVORITE = 3
  case sTACK = 4
}

enum ClickActionDto: Int {
  case bUTTON = 0
  case sWIPE = 1
  case gAME = 2
  case dEEPLINK = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryAPIDataDto {
  var id: Int64
  var storyData: StoryDataDto
  var imageFilePath: String? = nil
  var videoFilePath: String? = nil
  var hasAudio: Bool
  var title: String
  var titleColor: String
  var backgroundColor: String
  var opened: Bool
  var aspectRatio: Double



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryAPIDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let storyData = pigeonVar_list[1] as! StoryDataDto
    let imageFilePath: String? = nilOrValue(pigeonVar_list[2])
    let videoFilePath: String? = nilOrValue(pigeonVar_list[3])
    let hasAudio = pigeonVar_list[4] as! Bool
    let title = pigeonVar_list[5] as! String
    let titleColor = pigeonVar_list[6] as! String
    let backgroundColor = pigeonVar_list[7] as! String
    let opened = pigeonVar_list[8] as! Bool
    let aspectRatio = pigeonVar_list[9] as! Double

    return StoryAPIDataDto(
      id: id,
      storyData: storyData,
      imageFilePath: imageFilePath,
      videoFilePath: videoFilePath,
      hasAudio: hasAudio,
      title: title,
      titleColor: titleColor,
      backgroundColor: backgroundColor,
      opened: opened,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      storyData,
      imageFilePath,
      videoFilePath,
      hasAudio,
      title,
      titleColor,
      backgroundColor,
      opened,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryDataDto {
  var id: Int64
  var title: String
  var tags: String
  var feed: String
  var sourceType: SourceTypeDto
  var slidesCount: Int64
  var storyType: StoryTypeDto



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let title = pigeonVar_list[1] as! String
    let tags = pigeonVar_list[2] as! String
    let feed = pigeonVar_list[3] as! String
    let sourceType = pigeonVar_list[4] as! SourceTypeDto
    let slidesCount = pigeonVar_list[5] as! Int64
    let storyType = pigeonVar_list[6] as! StoryTypeDto

    return StoryDataDto(
      id: id,
      title: title,
      tags: tags,
      feed: feed,
      sourceType: sourceType,
      slidesCount: slidesCount,
      storyType: storyType
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      tags,
      feed,
      sourceType,
      slidesCount,
      storyType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SlideDataDto {
  var story: StoryDataDto
  var index: Int64
  var payload: String? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SlideDataDto? {
    let story = pigeonVar_list[0] as! StoryDataDto
    let index = pigeonVar_list[1] as! Int64
    let payload: String? = nilOrValue(pigeonVar_list[2])

    return SlideDataDto(
      story: story,
      index: index,
      payload: payload
    )
  }
  func toList() -> [Any?] {
    return [
      story,
      index,
      payload,
    ]
  }
}

private class PigeonGeneratedPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StoryTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SourceTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ClickActionDto(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      return StoryAPIDataDto.fromList(self.readValue() as! [Any?])
    case 133:
      return StoryDataDto.fromList(self.readValue() as! [Any?])
    case 134:
      return SlideDataDto.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PigeonGeneratedPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? StoryTypeDto {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? SourceTypeDto {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ClickActionDto {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? StoryAPIDataDto {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? StoryDataDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? SlideDataDto {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PigeonGeneratedPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PigeonGeneratedPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PigeonGeneratedPigeonCodecWriter(data: data)
  }
}

class PigeonGeneratedPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PigeonGeneratedPigeonCodec(readerWriter: PigeonGeneratedPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InappstorySdkModuleHostApi {
  func initWith(apiKey: String, userID: String, sendStatistics: Bool) throws
  func getStories(feed: String) throws
  func setPlaceholders(newPlaceholders: [String: String]) throws
  func setTags(tags: [String]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InappstorySdkModuleHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InappstorySdkModuleHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InappstorySdkModuleHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initWithChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.initWith\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initWithChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let apiKeyArg = args[0] as! String
        let userIDArg = args[1] as! String
        let sendStatisticsArg = args[2] as! Bool
        do {
          try api.initWith(apiKey: apiKeyArg, userID: userIDArg, sendStatistics: sendStatisticsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initWithChannel.setMessageHandler(nil)
    }
    let getStoriesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.getStories\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStoriesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        do {
          try api.getStories(feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStoriesChannel.setMessageHandler(nil)
    }
    let setPlaceholdersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.setPlaceholders\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaceholdersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let newPlaceholdersArg = args[0] as! [String: String]
        do {
          try api.setPlaceholders(newPlaceholders: newPlaceholdersArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaceholdersChannel.setMessageHandler(nil)
    }
    let setTagsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.setTags\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTagsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagsArg = args[0] as! [String]
        do {
          try api.setTags(tags: tagsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTagsChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASManager {
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASManagerSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InAppStoryAPI {
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InAppStoryAPISetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InAppStoryAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InAppStoryAPI?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASStoryListHostApi {
  func load(feed: String, hasFavorite: Bool, isFavorite: Bool) throws
  func openStoryReader(storyId: Int64) throws
  func showFavoriteItem() throws
  func updateVisiblePreviews(storyIds: [Int64]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASStoryListHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASStoryListHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASStoryListHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.load\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        let hasFavoriteArg = args[1] as! Bool
        let isFavoriteArg = args[2] as! Bool
        do {
          try api.load(feed: feedArg, hasFavorite: hasFavoriteArg, isFavorite: isFavoriteArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadChannel.setMessageHandler(nil)
    }
    let openStoryReaderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.openStoryReader\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openStoryReaderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! Int64
        do {
          try api.openStoryReader(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      openStoryReaderChannel.setMessageHandler(nil)
    }
    let showFavoriteItemChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.showFavoriteItem\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showFavoriteItemChannel.setMessageHandler { _, reply in
        do {
          try api.showFavoriteItem()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showFavoriteItemChannel.setMessageHandler(nil)
    }
    let updateVisiblePreviewsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.updateVisiblePreviews\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateVisiblePreviewsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdsArg = args[0] as! [Int64]
        do {
          try api.updateVisiblePreviews(storyIds: storyIdsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateVisiblePreviewsChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol InAppStoryAPIListSubscriberFlutterApiProtocol {
  func storyIsOpened(var1 var1Arg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func readerIsOpened(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func readerIsClosed(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class InAppStoryAPIListSubscriberFlutterApi: InAppStoryAPIListSubscriberFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func storyIsOpened(var1 var1Arg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.storyIsOpened\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([var1Arg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoryData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([var1Arg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoriesData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([listArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func readerIsOpened(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.readerIsOpened\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func readerIsClosed(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.readerIsClosed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol ErrorCallbackFlutterApiProtocol {
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func loadOnboardingError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func loadSingleError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func readerError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class ErrorCallbackFlutterApi: ErrorCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadListError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func loadOnboardingError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadOnboardingError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func loadSingleError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadSingleError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.cacheError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func readerError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.readerError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.emptyLinkError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.sessionError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.noConnection\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CallToActionCallbackFlutterApiProtocol {
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class CallToActionCallbackFlutterApi: CallToActionCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.CallToActionCallbackFlutterApi.callToAction\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, urlArg, clickActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
