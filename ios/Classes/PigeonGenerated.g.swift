// Autogenerated from Pigeon (v26.1.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsPigeonGenerated(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsPigeonGenerated(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsPigeonGenerated(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashPigeonGenerated(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashPigeonGenerated(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashPigeonGenerated(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

enum StoryTypeDto: Int {
  case cOMMON = 0
  case uGC = 1
}

enum SourceTypeDto: Int {
  case sINGLE = 0
  case oNBOARDING = 1
  case lIST = 2
  case fAVORITE = 3
  case sTACK = 4
}

enum ClickActionDto: Int {
  case bUTTON = 0
  case sWIPE = 1
  case gAME = 2
  case dEEPLINK = 3
}

enum Position: Int {
  case topLeft = 0
  case topRight = 1
  case bottomLeft = 2
  case bottomRight = 3
}

enum CoverQuality: Int {
  case medium = 0
  case high = 1
}

enum ContentTypeDto: Int {
  case sTORY = 0
  case uGC = 1
  case iNAPPMESSAGE = 2
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryAPIDataDto: Hashable {
  var id: Int64
  var storyData: StoryDataDto
  var imageFilePath: String? = nil
  var videoFilePath: String? = nil
  var hasAudio: Bool
  var title: String
  var titleColor: String
  var backgroundColor: String
  var opened: Bool
  var aspectRatio: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryAPIDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let storyData = pigeonVar_list[1] as! StoryDataDto
    let imageFilePath: String? = nilOrValue(pigeonVar_list[2])
    let videoFilePath: String? = nilOrValue(pigeonVar_list[3])
    let hasAudio = pigeonVar_list[4] as! Bool
    let title = pigeonVar_list[5] as! String
    let titleColor = pigeonVar_list[6] as! String
    let backgroundColor = pigeonVar_list[7] as! String
    let opened = pigeonVar_list[8] as! Bool
    let aspectRatio = pigeonVar_list[9] as! Double

    return StoryAPIDataDto(
      id: id,
      storyData: storyData,
      imageFilePath: imageFilePath,
      videoFilePath: videoFilePath,
      hasAudio: hasAudio,
      title: title,
      titleColor: titleColor,
      backgroundColor: backgroundColor,
      opened: opened,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      storyData,
      imageFilePath,
      videoFilePath,
      hasAudio,
      title,
      titleColor,
      backgroundColor,
      opened,
      aspectRatio,
    ]
  }
  static func == (lhs: StoryAPIDataDto, rhs: StoryAPIDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryDataDto: Hashable {
  var id: Int64
  var title: String? = nil
  var tags: String? = nil
  var feed: String? = nil
  var sourceType: SourceTypeDto? = nil
  var slidesCount: Int64
  var storyType: StoryTypeDto? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let title: String? = nilOrValue(pigeonVar_list[1])
    let tags: String? = nilOrValue(pigeonVar_list[2])
    let feed: String? = nilOrValue(pigeonVar_list[3])
    let sourceType: SourceTypeDto? = nilOrValue(pigeonVar_list[4])
    let slidesCount = pigeonVar_list[5] as! Int64
    let storyType: StoryTypeDto? = nilOrValue(pigeonVar_list[6])

    return StoryDataDto(
      id: id,
      title: title,
      tags: tags,
      feed: feed,
      sourceType: sourceType,
      slidesCount: slidesCount,
      storyType: storyType
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      tags,
      feed,
      sourceType,
      slidesCount,
      storyType,
    ]
  }
  static func == (lhs: StoryDataDto, rhs: StoryDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SlideDataDto: Hashable {
  var story: StoryDataDto? = nil
  var index: Int64
  var payload: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SlideDataDto? {
    let story: StoryDataDto? = nilOrValue(pigeonVar_list[0])
    let index = pigeonVar_list[1] as! Int64
    let payload: String? = nilOrValue(pigeonVar_list[2])

    return SlideDataDto(
      story: story,
      index: index,
      payload: payload
    )
  }
  func toList() -> [Any?] {
    return [
      story,
      index,
      payload,
    ]
  }
  static func == (lhs: SlideDataDto, rhs: SlideDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct GoodsItemAppearanceDto: Hashable {
  var itemBackgroundColor: Int64? = nil
  var itemCornerRadius: Int64? = nil
  var itemMainTextColor: Int64? = nil
  var itemOldPriceTextColor: Int64? = nil
  var itemTitleTextSize: Int64? = nil
  var itemDescriptionTextSize: Int64? = nil
  var itemPriceTextSize: Int64? = nil
  var itemOldPriceTextSize: Int64? = nil
  var widgetBackgroundColor: Int64? = nil
  var closeButtonImage: String? = nil
  var closeButtonColor: Int64? = nil
  var widgetBackgroundHeight: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GoodsItemAppearanceDto? {
    let itemBackgroundColor: Int64? = nilOrValue(pigeonVar_list[0])
    let itemCornerRadius: Int64? = nilOrValue(pigeonVar_list[1])
    let itemMainTextColor: Int64? = nilOrValue(pigeonVar_list[2])
    let itemOldPriceTextColor: Int64? = nilOrValue(pigeonVar_list[3])
    let itemTitleTextSize: Int64? = nilOrValue(pigeonVar_list[4])
    let itemDescriptionTextSize: Int64? = nilOrValue(pigeonVar_list[5])
    let itemPriceTextSize: Int64? = nilOrValue(pigeonVar_list[6])
    let itemOldPriceTextSize: Int64? = nilOrValue(pigeonVar_list[7])
    let widgetBackgroundColor: Int64? = nilOrValue(pigeonVar_list[8])
    let closeButtonImage: String? = nilOrValue(pigeonVar_list[9])
    let closeButtonColor: Int64? = nilOrValue(pigeonVar_list[10])
    let widgetBackgroundHeight: Int64? = nilOrValue(pigeonVar_list[11])

    return GoodsItemAppearanceDto(
      itemBackgroundColor: itemBackgroundColor,
      itemCornerRadius: itemCornerRadius,
      itemMainTextColor: itemMainTextColor,
      itemOldPriceTextColor: itemOldPriceTextColor,
      itemTitleTextSize: itemTitleTextSize,
      itemDescriptionTextSize: itemDescriptionTextSize,
      itemPriceTextSize: itemPriceTextSize,
      itemOldPriceTextSize: itemOldPriceTextSize,
      widgetBackgroundColor: widgetBackgroundColor,
      closeButtonImage: closeButtonImage,
      closeButtonColor: closeButtonColor,
      widgetBackgroundHeight: widgetBackgroundHeight
    )
  }
  func toList() -> [Any?] {
    return [
      itemBackgroundColor,
      itemCornerRadius,
      itemMainTextColor,
      itemOldPriceTextColor,
      itemTitleTextSize,
      itemDescriptionTextSize,
      itemPriceTextSize,
      itemOldPriceTextSize,
      widgetBackgroundColor,
      closeButtonImage,
      closeButtonColor,
      widgetBackgroundHeight,
    ]
  }
  static func == (lhs: GoodsItemAppearanceDto, rhs: GoodsItemAppearanceDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct GoodsItemDataDto: Hashable {
  var sku: String? = nil
  var title: String? = nil
  var description: String? = nil
  var image: String? = nil
  var price: String? = nil
  var oldPrice: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GoodsItemDataDto? {
    let sku: String? = nilOrValue(pigeonVar_list[0])
    let title: String? = nilOrValue(pigeonVar_list[1])
    let description: String? = nilOrValue(pigeonVar_list[2])
    let image: String? = nilOrValue(pigeonVar_list[3])
    let price: String? = nilOrValue(pigeonVar_list[4])
    let oldPrice: String? = nilOrValue(pigeonVar_list[5])

    return GoodsItemDataDto(
      sku: sku,
      title: title,
      description: description,
      image: image,
      price: price,
      oldPrice: oldPrice
    )
  }
  func toList() -> [Any?] {
    return [
      sku,
      title,
      description,
      image,
      price,
      oldPrice,
    ]
  }
  static func == (lhs: GoodsItemDataDto, rhs: GoodsItemDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryFavoriteItemAPIDataDto: Hashable {
  var id: Int64
  var imageFilePath: String? = nil
  var backgroundColor: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryFavoriteItemAPIDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let imageFilePath: String? = nilOrValue(pigeonVar_list[1])
    let backgroundColor = pigeonVar_list[2] as! String

    return StoryFavoriteItemAPIDataDto(
      id: id,
      imageFilePath: imageFilePath,
      backgroundColor: backgroundColor
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      imageFilePath,
      backgroundColor,
    ]
  }
  static func == (lhs: StoryFavoriteItemAPIDataDto, rhs: StoryFavoriteItemAPIDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ContentDataDto: Hashable {
  var contentType: ContentTypeDto? = nil
  var sourceType: SourceTypeDto? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ContentDataDto? {
    let contentType: ContentTypeDto? = nilOrValue(pigeonVar_list[0])
    let sourceType: SourceTypeDto? = nilOrValue(pigeonVar_list[1])

    return ContentDataDto(
      contentType: contentType,
      sourceType: sourceType
    )
  }
  func toList() -> [Any?] {
    return [
      contentType,
      sourceType,
    ]
  }
  static func == (lhs: ContentDataDto, rhs: ContentDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

/// Represents data for an in-app message.
///
/// This class contains information about an in-app message, including its
/// unique identifier, title, and associated event.
///
/// Generated class from Pigeon that represents data sent in messages.
struct InAppMessageDataDto: Hashable {
  /// The unique identifier of the in-app message.
  var id: Int64
  /// The title of the in-app message, or `null` if not available.
  var title: String? = nil
  /// The event associated with the in-app message, or `null` if not available.
  var event: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> InAppMessageDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let title: String? = nilOrValue(pigeonVar_list[1])
    let event: String? = nilOrValue(pigeonVar_list[2])

    return InAppMessageDataDto(
      id: id,
      title: title,
      event: event
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      event,
    ]
  }
  static func == (lhs: InAppMessageDataDto, rhs: InAppMessageDataDto) -> Bool {
    return deepEqualsPigeonGenerated(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashPigeonGenerated(value: toList(), hasher: &hasher)
  }
}

private class PigeonGeneratedPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StoryTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SourceTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ClickActionDto(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return Position(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CoverQuality(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ContentTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      return StoryAPIDataDto.fromList(self.readValue() as! [Any?])
    case 136:
      return StoryDataDto.fromList(self.readValue() as! [Any?])
    case 137:
      return SlideDataDto.fromList(self.readValue() as! [Any?])
    case 138:
      return GoodsItemAppearanceDto.fromList(self.readValue() as! [Any?])
    case 139:
      return GoodsItemDataDto.fromList(self.readValue() as! [Any?])
    case 140:
      return StoryFavoriteItemAPIDataDto.fromList(self.readValue() as! [Any?])
    case 141:
      return ContentDataDto.fromList(self.readValue() as! [Any?])
    case 142:
      return InAppMessageDataDto.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PigeonGeneratedPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? StoryTypeDto {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? SourceTypeDto {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ClickActionDto {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? Position {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? CoverQuality {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? ContentTypeDto {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? StoryAPIDataDto {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? StoryDataDto {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? SlideDataDto {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? GoodsItemAppearanceDto {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? GoodsItemDataDto {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? StoryFavoriteItemAPIDataDto {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? ContentDataDto {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? InAppMessageDataDto {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PigeonGeneratedPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PigeonGeneratedPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PigeonGeneratedPigeonCodecWriter(data: data)
  }
}

class PigeonGeneratedPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PigeonGeneratedPigeonCodec(readerWriter: PigeonGeneratedPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InappstorySdkModuleHostApi {
  func initWith(apiKey: String, userID: String, anonymous: Bool, userSign: String?, languageCode: String?, languageRegion: String?, cacheSize: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func createListAdaptor(feed: String, uniqueId: String) throws
  func removeListAdaptor(feed: String, uniqueId: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InappstorySdkModuleHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InappstorySdkModuleHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InappstorySdkModuleHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initWithChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.initWith\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initWithChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let apiKeyArg = args[0] as! String
        let userIDArg = args[1] as! String
        let anonymousArg = args[2] as! Bool
        let userSignArg: String? = nilOrValue(args[3])
        let languageCodeArg: String? = nilOrValue(args[4])
        let languageRegionArg: String? = nilOrValue(args[5])
        let cacheSizeArg: String? = nilOrValue(args[6])
        api.initWith(apiKey: apiKeyArg, userID: userIDArg, anonymous: anonymousArg, userSign: userSignArg, languageCode: languageCodeArg, languageRegion: languageRegionArg, cacheSize: cacheSizeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initWithChannel.setMessageHandler(nil)
    }
    let createListAdaptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.createListAdaptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createListAdaptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        let uniqueIdArg = args[1] as! String
        do {
          try api.createListAdaptor(feed: feedArg, uniqueId: uniqueIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createListAdaptorChannel.setMessageHandler(nil)
    }
    let removeListAdaptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.removeListAdaptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeListAdaptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        let uniqueIdArg = args[1] as! String
        do {
          try api.removeListAdaptor(feed: feedArg, uniqueId: uniqueIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeListAdaptorChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InAppStoryManagerHostApi {
  func setPlaceholders(newPlaceholders: [String: String]) throws
  func setTags(tags: [String]) throws
  func changeUser(userId: String, userSign: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func userLogout() throws
  func closeReaders(completion: @escaping (Result<Void, Error>) -> Void)
  func clearCache() throws
  func setLang(languageCode: String, languageRegion: String) throws
  func setTransparentStatusBar() throws
  func changeSound(value: Bool) throws
  func setUserSettings(anonymous: Bool?, userId: String?, userSign: String?, newLanguageCode: String?, newLanguageRegion: String?, newTags: [String]?, newPlaceholders: [String: String]?) throws
  func setOptionKeys(options: [String: String]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InAppStoryManagerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InAppStoryManagerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InAppStoryManagerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setPlaceholdersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setPlaceholders\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaceholdersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let newPlaceholdersArg = args[0] as! [String: String]
        do {
          try api.setPlaceholders(newPlaceholders: newPlaceholdersArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaceholdersChannel.setMessageHandler(nil)
    }
    let setTagsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setTags\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTagsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagsArg = args[0] as! [String]
        do {
          try api.setTags(tags: tagsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTagsChannel.setMessageHandler(nil)
    }
    let changeUserChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.changeUser\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      changeUserChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let userIdArg = args[0] as! String
        let userSignArg: String? = nilOrValue(args[1])
        api.changeUser(userId: userIdArg, userSign: userSignArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      changeUserChannel.setMessageHandler(nil)
    }
    let userLogoutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.userLogout\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      userLogoutChannel.setMessageHandler { _, reply in
        do {
          try api.userLogout()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      userLogoutChannel.setMessageHandler(nil)
    }
    let closeReadersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.closeReaders\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeReadersChannel.setMessageHandler { _, reply in
        api.closeReaders { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      closeReadersChannel.setMessageHandler(nil)
    }
    let clearCacheChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.clearCache\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearCacheChannel.setMessageHandler { _, reply in
        do {
          try api.clearCache()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearCacheChannel.setMessageHandler(nil)
    }
    let setLangChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setLang\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLangChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageCodeArg = args[0] as! String
        let languageRegionArg = args[1] as! String
        do {
          try api.setLang(languageCode: languageCodeArg, languageRegion: languageRegionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLangChannel.setMessageHandler(nil)
    }
    let setTransparentStatusBarChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setTransparentStatusBar\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTransparentStatusBarChannel.setMessageHandler { _, reply in
        do {
          try api.setTransparentStatusBar()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTransparentStatusBarChannel.setMessageHandler(nil)
    }
    let changeSoundChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.changeSound\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      changeSoundChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.changeSound(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      changeSoundChannel.setMessageHandler(nil)
    }
    let setUserSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setUserSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anonymousArg: Bool? = nilOrValue(args[0])
        let userIdArg: String? = nilOrValue(args[1])
        let userSignArg: String? = nilOrValue(args[2])
        let newLanguageCodeArg: String? = nilOrValue(args[3])
        let newLanguageRegionArg: String? = nilOrValue(args[4])
        let newTagsArg: [String]? = nilOrValue(args[5])
        let newPlaceholdersArg: [String: String]? = nilOrValue(args[6])
        do {
          try api.setUserSettings(anonymous: anonymousArg, userId: userIdArg, userSign: userSignArg, newLanguageCode: newLanguageCodeArg, newLanguageRegion: newLanguageRegionArg, newTags: newTagsArg, newPlaceholders: newPlaceholdersArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserSettingsChannel.setMessageHandler(nil)
    }
    let setOptionKeysChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setOptionKeys\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setOptionKeysChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! [String: String]
        do {
          try api.setOptionKeys(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOptionKeysChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASStoryListHostApi {
  func load(feed: String, uniqueId: String) throws
  func reloadFeed(feed: String) throws
  func openStoryReader(storyId: Int64, feed: String) throws
  func showFavoriteItem(feed: String) throws
  func updateVisiblePreviews(storyIds: [Int64], feed: String) throws
  func removeSubscriber(feed: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASStoryListHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASStoryListHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASStoryListHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.load\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        let uniqueIdArg = args[1] as! String
        do {
          try api.load(feed: feedArg, uniqueId: uniqueIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadChannel.setMessageHandler(nil)
    }
    let reloadFeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.reloadFeed\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reloadFeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        do {
          try api.reloadFeed(feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reloadFeedChannel.setMessageHandler(nil)
    }
    let openStoryReaderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.openStoryReader\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openStoryReaderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! Int64
        let feedArg = args[1] as! String
        do {
          try api.openStoryReader(storyId: storyIdArg, feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      openStoryReaderChannel.setMessageHandler(nil)
    }
    let showFavoriteItemChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.showFavoriteItem\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showFavoriteItemChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        do {
          try api.showFavoriteItem(feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showFavoriteItemChannel.setMessageHandler(nil)
    }
    let updateVisiblePreviewsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.updateVisiblePreviews\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateVisiblePreviewsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdsArg = args[0] as! [Int64]
        let feedArg = args[1] as! String
        do {
          try api.updateVisiblePreviews(storyIds: storyIdsArg, feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateVisiblePreviewsChannel.setMessageHandler(nil)
    }
    let removeSubscriberChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.removeSubscriber\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeSubscriberChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        do {
          try api.removeSubscriber(feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeSubscriberChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol InAppStoryAPIListSubscriberFlutterApiProtocol {
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateFavoriteStoriesData(list listArg: [StoryFavoriteItemAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func storiesLoaded(size sizeArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func scrollToStory(index indexArg: Int64, feed feedArg: String, uniqueId uniqueIdArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class InAppStoryAPIListSubscriberFlutterApi: InAppStoryAPIListSubscriberFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoryData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([var1Arg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoriesData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([listArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func updateFavoriteStoriesData(list listArg: [StoryFavoriteItemAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateFavoriteStoriesData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([listArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func storiesLoaded(size sizeArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.storiesLoaded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([sizeArg, feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func scrollToStory(index indexArg: Int64, feed feedArg: String, uniqueId uniqueIdArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.scrollToStory\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([indexArg, feedArg, uniqueIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol ErrorCallbackFlutterApiProtocol {
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class ErrorCallbackFlutterApi: ErrorCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadListError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.cacheError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.emptyLinkError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.sessionError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.noConnection\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CallToActionCallbackFlutterApiProtocol {
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class CallToActionCallbackFlutterApi: CallToActionCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.CallToActionCallbackFlutterApi.callToAction\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, urlArg, clickActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AppearanceManagerHostApi {
  func setHasLike(value: Bool) throws
  func setHasFavorites(value: Bool) throws
  func setHasShare(value: Bool) throws
  func setClosePosition(position: Position) throws
  func setTimerGradientEnable(isEnabled: Bool) throws
  func getTimerGradientEnable() throws -> Bool
  func setTimerGradient(colors: [Int64], locations: [Double]) throws
  func setReaderBackgroundColor(color: Int64) throws
  func setReaderCornerRadius(radius: Int64) throws
  func setLikeIcon(iconPath: String, selectedIconPath: String) throws
  func setDislikeIcon(iconPath: String, selectedIconPath: String) throws
  func setFavoriteIcon(iconPath: String, selectedIconPath: String) throws
  func setShareIcon(iconPath: String, selectedIconPath: String) throws
  func setCloseIcon(iconPath: String) throws
  func setRefreshIcon(iconPath: String) throws
  func setSoundIcon(iconPath: String, selectedIconPath: String) throws
  func setUpGoods(appearance: GoodsItemAppearanceDto) throws
  func setCoverQuality(coverQuality: CoverQuality) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AppearanceManagerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `AppearanceManagerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AppearanceManagerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setHasLikeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasLike\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasLikeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasLike(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasLikeChannel.setMessageHandler(nil)
    }
    let setHasFavoritesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasFavorites\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasFavoritesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasFavorites(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasFavoritesChannel.setMessageHandler(nil)
    }
    let setHasShareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasShare\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasShareChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasShare(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasShareChannel.setMessageHandler(nil)
    }
    let setClosePositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setClosePosition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setClosePositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let positionArg = args[0] as! Position
        do {
          try api.setClosePosition(position: positionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setClosePositionChannel.setMessageHandler(nil)
    }
    let setTimerGradientEnableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradientEnable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTimerGradientEnableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let isEnabledArg = args[0] as! Bool
        do {
          try api.setTimerGradientEnable(isEnabled: isEnabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTimerGradientEnableChannel.setMessageHandler(nil)
    }
    let getTimerGradientEnableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.getTimerGradientEnable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTimerGradientEnableChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTimerGradientEnable()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTimerGradientEnableChannel.setMessageHandler(nil)
    }
    let setTimerGradientChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradient\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTimerGradientChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let colorsArg = args[0] as! [Int64]
        let locationsArg = args[1] as! [Double]
        do {
          try api.setTimerGradient(colors: colorsArg, locations: locationsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTimerGradientChannel.setMessageHandler(nil)
    }
    let setReaderBackgroundColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderBackgroundColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setReaderBackgroundColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let colorArg = args[0] as! Int64
        do {
          try api.setReaderBackgroundColor(color: colorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setReaderBackgroundColorChannel.setMessageHandler(nil)
    }
    let setReaderCornerRadiusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderCornerRadius\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setReaderCornerRadiusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let radiusArg = args[0] as! Int64
        do {
          try api.setReaderCornerRadius(radius: radiusArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setReaderCornerRadiusChannel.setMessageHandler(nil)
    }
    let setLikeIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setLikeIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLikeIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        let selectedIconPathArg = args[1] as! String
        do {
          try api.setLikeIcon(iconPath: iconPathArg, selectedIconPath: selectedIconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLikeIconChannel.setMessageHandler(nil)
    }
    let setDislikeIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setDislikeIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDislikeIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        let selectedIconPathArg = args[1] as! String
        do {
          try api.setDislikeIcon(iconPath: iconPathArg, selectedIconPath: selectedIconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDislikeIconChannel.setMessageHandler(nil)
    }
    let setFavoriteIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setFavoriteIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFavoriteIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        let selectedIconPathArg = args[1] as! String
        do {
          try api.setFavoriteIcon(iconPath: iconPathArg, selectedIconPath: selectedIconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setFavoriteIconChannel.setMessageHandler(nil)
    }
    let setShareIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setShareIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setShareIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        let selectedIconPathArg = args[1] as! String
        do {
          try api.setShareIcon(iconPath: iconPathArg, selectedIconPath: selectedIconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setShareIconChannel.setMessageHandler(nil)
    }
    let setCloseIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setCloseIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCloseIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        do {
          try api.setCloseIcon(iconPath: iconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCloseIconChannel.setMessageHandler(nil)
    }
    let setRefreshIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setRefreshIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setRefreshIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        do {
          try api.setRefreshIcon(iconPath: iconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setRefreshIconChannel.setMessageHandler(nil)
    }
    let setSoundIconChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setSoundIcon\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSoundIconChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let iconPathArg = args[0] as! String
        let selectedIconPathArg = args[1] as! String
        do {
          try api.setSoundIcon(iconPath: iconPathArg, selectedIconPath: selectedIconPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSoundIconChannel.setMessageHandler(nil)
    }
    let setUpGoodsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setUpGoods\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUpGoodsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appearanceArg = args[0] as! GoodsItemAppearanceDto
        do {
          try api.setUpGoods(appearance: appearanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUpGoodsChannel.setMessageHandler(nil)
    }
    let setCoverQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setCoverQuality\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCoverQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coverQualityArg = args[0] as! CoverQuality
        do {
          try api.setCoverQuality(coverQuality: coverQualityArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCoverQualityChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol SkusCallbackFlutterApiProtocol {
  func getSkus(strings stringsArg: [String], completion: @escaping (Result<[GoodsItemDataDto], PigeonError>) -> Void)
}
class SkusCallbackFlutterApi: SkusCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func getSkus(strings stringsArg: [String], completion: @escaping (Result<[GoodsItemDataDto], PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.SkusCallbackFlutterApi.getSkus\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([stringsArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [GoodsItemDataDto]
        completion(.success(result))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol GoodsItemSelectedCallbackFlutterApiProtocol {
  func goodsItemSelected(item itemArg: GoodsItemDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class GoodsItemSelectedCallbackFlutterApi: GoodsItemSelectedCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func goodsItemSelected(item itemArg: GoodsItemDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GoodsItemSelectedCallbackFlutterApi.goodsItemSelected\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([itemArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASSingleStoryHostApi {
  func showOnce(storyId: String) throws
  func show(storyId: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASSingleStoryHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASSingleStoryHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASSingleStoryHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let showOnceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.showOnce\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showOnceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! String
        do {
          try api.showOnce(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showOnceChannel.setMessageHandler(nil)
    }
    let showChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.show\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! String
        do {
          try api.show(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol IShowStoryCallbackFlutterApiProtocol {
  func onShow(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func alreadyShown(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class IShowStoryCallbackFlutterApi: IShowStoryCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onShow(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryCallbackFlutterApi.onShow\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryCallbackFlutterApi.onError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func alreadyShown(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryCallbackFlutterApi.alreadyShown\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol SingleLoadCallbackFlutterApiProtocol {
  func singleLoadSuccess(storyData storyDataArg: StoryDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func singleLoadError(storyId storyIdArg: String?, reason reasonArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class SingleLoadCallbackFlutterApi: SingleLoadCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func singleLoadSuccess(storyData storyDataArg: StoryDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.SingleLoadCallbackFlutterApi.singleLoadSuccess\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([storyDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func singleLoadError(storyId storyIdArg: String?, reason reasonArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.SingleLoadCallbackFlutterApi.singleLoadError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([storyIdArg, reasonArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASOnboardingsHostApi {
  /// [feed] by default == "onboarding"
  /// [limit] has to be set greater than 0 (can be set as any big number if limits is unnecessary)
  func show(limit: Int64, feed: String, tags: [String]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASOnboardingsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASOnboardingsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASOnboardingsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// [feed] by default == "onboarding"
    /// [limit] has to be set greater than 0 (can be set as any big number if limits is unnecessary)
    let showChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASOnboardingsHostApi.show\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let limitArg = args[0] as! Int64
        let feedArg = args[1] as! String
        let tagsArg = args[2] as! [String]
        do {
          try api.show(limit: limitArg, feed: feedArg, tags: tagsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnboardingLoadCallbackFlutterApiProtocol {
  func onboardingLoadSuccess(count countArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onboardingLoadError(feed feedArg: String, reason reasonArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class OnboardingLoadCallbackFlutterApi: OnboardingLoadCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onboardingLoadSuccess(count countArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.OnboardingLoadCallbackFlutterApi.onboardingLoadSuccess\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([countArg, feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onboardingLoadError(feed feedArg: String, reason reasonArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.OnboardingLoadCallbackFlutterApi.onboardingLoadError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg, reasonArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASGamesHostApi {
  func openGame(gameId: String) throws
  func closeGame() throws
  func preloadGames() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASGamesHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASGamesHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASGamesHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let openGameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASGamesHostApi.openGame\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openGameChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let gameIdArg = args[0] as! String
        do {
          try api.openGame(gameId: gameIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      openGameChannel.setMessageHandler(nil)
    }
    let closeGameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASGamesHostApi.closeGame\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeGameChannel.setMessageHandler { _, reply in
        do {
          try api.closeGame()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeGameChannel.setMessageHandler(nil)
    }
    let preloadGamesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASGamesHostApi.preloadGames\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      preloadGamesChannel.setMessageHandler { _, reply in
        do {
          try api.preloadGames()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      preloadGamesChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol GameReaderCallbackFlutterApiProtocol {
  func startGame(contentData contentDataArg: ContentDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func finishGame(contentData contentDataArg: ContentDataDto?, result resultArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func closeGame(contentData contentDataArg: ContentDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func eventGame(contentData contentDataArg: ContentDataDto?, gameId gameIdArg: String?, eventName eventNameArg: String?, payload payloadArg: [String: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func gameError(contentData contentDataArg: ContentDataDto?, message messageArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class GameReaderCallbackFlutterApi: GameReaderCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func startGame(contentData contentDataArg: ContentDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GameReaderCallbackFlutterApi.startGame\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([contentDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func finishGame(contentData contentDataArg: ContentDataDto?, result resultArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GameReaderCallbackFlutterApi.finishGame\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([contentDataArg, resultArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func closeGame(contentData contentDataArg: ContentDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GameReaderCallbackFlutterApi.closeGame\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([contentDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func eventGame(contentData contentDataArg: ContentDataDto?, gameId gameIdArg: String?, eventName eventNameArg: String?, payload payloadArg: [String: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GameReaderCallbackFlutterApi.eventGame\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([contentDataArg, gameIdArg, eventNameArg, payloadArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func gameError(contentData contentDataArg: ContentDataDto?, message messageArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.GameReaderCallbackFlutterApi.gameError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([contentDataArg, messageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol IASCallBacksFlutterApiProtocol {
  func onShowStory(storyData storyDataArg: StoryDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onCloseStory(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onFavoriteTap(slideData slideDataArg: SlideDataDto?, isFavorite isFavoriteArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onLikeStoryTap(slideData slideDataArg: SlideDataDto?, isLike isLikeArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onDislikeStoryTap(slideData slideDataArg: SlideDataDto?, isDislike isDislikeArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onShareStory(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onShowSlide(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onStoryWidgetEvent(slideData slideDataArg: SlideDataDto?, widgetData widgetDataArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class IASCallBacksFlutterApi: IASCallBacksFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onShowStory(storyData storyDataArg: StoryDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onShowStory\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([storyDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onCloseStory(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onCloseStory\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onFavoriteTap(slideData slideDataArg: SlideDataDto?, isFavorite isFavoriteArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onFavoriteTap\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, isFavoriteArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onLikeStoryTap(slideData slideDataArg: SlideDataDto?, isLike isLikeArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onLikeStoryTap\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, isLikeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDislikeStoryTap(slideData slideDataArg: SlideDataDto?, isDislike isDislikeArg: Bool, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onDislikeStoryTap\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, isDislikeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onShareStory(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onShareStory\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onShowSlide(slideData slideDataArg: SlideDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onShowSlide\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onStoryWidgetEvent(slideData slideDataArg: SlideDataDto?, widgetData widgetDataArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASCallBacksFlutterApi.onStoryWidgetEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, widgetDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASInAppMessagesHostApi {
  func showById(messageId: String, onlyPreloaded: Bool) throws
  func showByEvent(event: String, onlyPreloaded: Bool) throws
  func preloadMessages(ids: [String]?, completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASInAppMessagesHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASInAppMessagesHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASInAppMessagesHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let showByIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesHostApi.showById\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showByIdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let messageIdArg = args[0] as! String
        let onlyPreloadedArg = args[1] as! Bool
        do {
          try api.showById(messageId: messageIdArg, onlyPreloaded: onlyPreloadedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showByIdChannel.setMessageHandler(nil)
    }
    let showByEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesHostApi.showByEvent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showByEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! String
        let onlyPreloadedArg = args[1] as! Bool
        do {
          try api.showByEvent(event: eventArg, onlyPreloaded: onlyPreloadedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showByEventChannel.setMessageHandler(nil)
    }
    let preloadMessagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesHostApi.preloadMessages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      preloadMessagesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idsArg: [String]? = nilOrValue(args[0])
        api.preloadMessages(ids: idsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      preloadMessagesChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol IASInAppMessagesCallbacksFlutterApiProtocol {
  func onShowInAppMessage(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onCloseInAppMessage(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onInAppMessageWidgetEvent(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, name nameArg: String?, data dataArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class IASInAppMessagesCallbacksFlutterApi: IASInAppMessagesCallbacksFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onShowInAppMessage(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesCallbacksFlutterApi.onShowInAppMessage\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([inAppMessageDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onCloseInAppMessage(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesCallbacksFlutterApi.onCloseInAppMessage\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([inAppMessageDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onInAppMessageWidgetEvent(inAppMessageData inAppMessageDataArg: InAppMessageDataDto?, name nameArg: String?, data dataArg: [String?: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IASInAppMessagesCallbacksFlutterApi.onInAppMessageWidgetEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([inAppMessageDataArg, nameArg, dataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
