// Autogenerated from Pigeon (v22.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum StoryTypeDto: Int {
  case cOMMON = 0
  case uGC = 1
}

enum SourceTypeDto: Int {
  case sINGLE = 0
  case oNBOARDING = 1
  case lIST = 2
  case fAVORITE = 3
  case sTACK = 4
}

enum ClickActionDto: Int {
  case bUTTON = 0
  case sWIPE = 1
  case gAME = 2
  case dEEPLINK = 3
}

enum Position: Int {
  case topLeft = 0
  case topRight = 1
  case bottomLeft = 2
  case bottomRight = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryAPIDataDto {
  var id: Int64
  var storyData: StoryDataDto
  var imageFilePath: String? = nil
  var videoFilePath: String? = nil
  var hasAudio: Bool
  var title: String
  var titleColor: String
  var backgroundColor: String
  var opened: Bool
  var aspectRatio: Double



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryAPIDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let storyData = pigeonVar_list[1] as! StoryDataDto
    let imageFilePath: String? = nilOrValue(pigeonVar_list[2])
    let videoFilePath: String? = nilOrValue(pigeonVar_list[3])
    let hasAudio = pigeonVar_list[4] as! Bool
    let title = pigeonVar_list[5] as! String
    let titleColor = pigeonVar_list[6] as! String
    let backgroundColor = pigeonVar_list[7] as! String
    let opened = pigeonVar_list[8] as! Bool
    let aspectRatio = pigeonVar_list[9] as! Double

    return StoryAPIDataDto(
      id: id,
      storyData: storyData,
      imageFilePath: imageFilePath,
      videoFilePath: videoFilePath,
      hasAudio: hasAudio,
      title: title,
      titleColor: titleColor,
      backgroundColor: backgroundColor,
      opened: opened,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      storyData,
      imageFilePath,
      videoFilePath,
      hasAudio,
      title,
      titleColor,
      backgroundColor,
      opened,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryDataDto {
  var id: Int64
  var title: String? = nil
  var tags: String? = nil
  var feed: String? = nil
  var sourceType: SourceTypeDto? = nil
  var slidesCount: Int64
  var storyType: StoryTypeDto? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let title: String? = nilOrValue(pigeonVar_list[1])
    let tags: String? = nilOrValue(pigeonVar_list[2])
    let feed: String? = nilOrValue(pigeonVar_list[3])
    let sourceType: SourceTypeDto? = nilOrValue(pigeonVar_list[4])
    let slidesCount = pigeonVar_list[5] as! Int64
    let storyType: StoryTypeDto? = nilOrValue(pigeonVar_list[6])

    return StoryDataDto(
      id: id,
      title: title,
      tags: tags,
      feed: feed,
      sourceType: sourceType,
      slidesCount: slidesCount,
      storyType: storyType
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      tags,
      feed,
      sourceType,
      slidesCount,
      storyType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SlideDataDto {
  var story: StoryDataDto
  var index: Int64
  var payload: String? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SlideDataDto? {
    let story = pigeonVar_list[0] as! StoryDataDto
    let index = pigeonVar_list[1] as! Int64
    let payload: String? = nilOrValue(pigeonVar_list[2])

    return SlideDataDto(
      story: story,
      index: index,
      payload: payload
    )
  }
  func toList() -> [Any?] {
    return [
      story,
      index,
      payload,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StoryFavoriteItemAPIDataDto {
  var id: Int64
  var imageFilePath: String? = nil
  var backgroundColor: String



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StoryFavoriteItemAPIDataDto? {
    let id = pigeonVar_list[0] as! Int64
    let imageFilePath: String? = nilOrValue(pigeonVar_list[1])
    let backgroundColor = pigeonVar_list[2] as! String

    return StoryFavoriteItemAPIDataDto(
      id: id,
      imageFilePath: imageFilePath,
      backgroundColor: backgroundColor
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      imageFilePath,
      backgroundColor,
    ]
  }
}

private class PigeonGeneratedPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StoryTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SourceTypeDto(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ClickActionDto(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return Position(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      return StoryAPIDataDto.fromList(self.readValue() as! [Any?])
    case 134:
      return StoryDataDto.fromList(self.readValue() as! [Any?])
    case 135:
      return SlideDataDto.fromList(self.readValue() as! [Any?])
    case 136:
      return StoryFavoriteItemAPIDataDto.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PigeonGeneratedPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? StoryTypeDto {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? SourceTypeDto {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ClickActionDto {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? Position {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? StoryAPIDataDto {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? StoryDataDto {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? SlideDataDto {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? StoryFavoriteItemAPIDataDto {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PigeonGeneratedPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PigeonGeneratedPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PigeonGeneratedPigeonCodecWriter(data: data)
  }
}

class PigeonGeneratedPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PigeonGeneratedPigeonCodec(readerWriter: PigeonGeneratedPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InappstorySdkModuleHostApi {
  func initWith(apiKey: String, userID: String, sendStatistics: Bool, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InappstorySdkModuleHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InappstorySdkModuleHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InappstorySdkModuleHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initWithChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InappstorySdkModuleHostApi.initWith\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initWithChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let apiKeyArg = args[0] as! String
        let userIDArg = args[1] as! String
        let sendStatisticsArg = args[2] as! Bool
        api.initWith(apiKey: apiKeyArg, userID: userIDArg, sendStatistics: sendStatisticsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initWithChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol InAppStoryManagerHostApi {
  func setPlaceholders(newPlaceholders: [String: String]) throws
  func setTags(tags: [String]) throws
  func changeUser(userId: String, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class InAppStoryManagerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `InAppStoryManagerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: InAppStoryManagerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setPlaceholdersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setPlaceholders\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaceholdersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let newPlaceholdersArg = args[0] as! [String: String]
        do {
          try api.setPlaceholders(newPlaceholders: newPlaceholdersArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaceholdersChannel.setMessageHandler(nil)
    }
    let setTagsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.setTags\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTagsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagsArg = args[0] as! [String]
        do {
          try api.setTags(tags: tagsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTagsChannel.setMessageHandler(nil)
    }
    let changeUserChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.InAppStoryManagerHostApi.changeUser\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      changeUserChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let userIdArg = args[0] as! String
        api.changeUser(userId: userIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      changeUserChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASStoryListHostApi {
  func load(feed: String) throws
  func openStoryReader(storyId: Int64) throws
  func showFavoriteItem() throws
  func updateVisiblePreviews(storyIds: [Int64]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASStoryListHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASStoryListHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASStoryListHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.load\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let feedArg = args[0] as! String
        do {
          try api.load(feed: feedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadChannel.setMessageHandler(nil)
    }
    let openStoryReaderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.openStoryReader\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openStoryReaderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! Int64
        do {
          try api.openStoryReader(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      openStoryReaderChannel.setMessageHandler(nil)
    }
    let showFavoriteItemChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.showFavoriteItem\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showFavoriteItemChannel.setMessageHandler { _, reply in
        do {
          try api.showFavoriteItem()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showFavoriteItemChannel.setMessageHandler(nil)
    }
    let updateVisiblePreviewsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASStoryListHostApi.updateVisiblePreviews\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateVisiblePreviewsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdsArg = args[0] as! [Int64]
        do {
          try api.updateVisiblePreviews(storyIds: storyIdsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateVisiblePreviewsChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol InAppStoryAPIListSubscriberFlutterApiProtocol {
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func updateFavoriteStoriesData(list listArg: [StoryFavoriteItemAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class InAppStoryAPIListSubscriberFlutterApi: InAppStoryAPIListSubscriberFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func updateStoryData(var1 var1Arg: StoryAPIDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoryData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([var1Arg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func updateStoriesData(list listArg: [StoryAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateStoriesData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([listArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func updateFavoriteStoriesData(list listArg: [StoryFavoriteItemAPIDataDto], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.InAppStoryAPIListSubscriberFlutterApi.updateFavoriteStoriesData\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([listArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol ErrorCallbackFlutterApiProtocol {
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func loadOnboardingError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func loadSingleError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func readerError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class ErrorCallbackFlutterApi: ErrorCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func loadListError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadListError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func loadOnboardingError(feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadOnboardingError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func loadSingleError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.loadSingleError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func cacheError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.cacheError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func readerError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.readerError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func emptyLinkError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.emptyLinkError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func sessionError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.sessionError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func noConnection(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.ErrorCallbackFlutterApi.noConnection\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CallToActionCallbackFlutterApiProtocol {
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class CallToActionCallbackFlutterApi: CallToActionCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func callToAction(slideData slideDataArg: SlideDataDto?, url urlArg: String?, clickAction clickActionArg: ClickActionDto?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.CallToActionCallbackFlutterApi.callToAction\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([slideDataArg, urlArg, clickActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AppearanceManagerHostApi {
  func setHasLike(value: Bool) throws
  func setHasFavorites(value: Bool) throws
  func setHasShare(value: Bool) throws
  func setClosePosition(position: Position) throws
  func setTimerGradientEnable(isEnabled: Bool) throws
  func getTimerGradientEnable() throws -> Bool
  func setTimerGradient(colors: [Int64], locations: [Double]) throws
  func setReaderBackgroundColor(color: Int64) throws
  func setReaderCornerRadius(radius: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AppearanceManagerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `AppearanceManagerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AppearanceManagerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setHasLikeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasLike\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasLikeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasLike(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasLikeChannel.setMessageHandler(nil)
    }
    let setHasFavoritesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasFavorites\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasFavoritesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasFavorites(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasFavoritesChannel.setMessageHandler(nil)
    }
    let setHasShareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setHasShare\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHasShareChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! Bool
        do {
          try api.setHasShare(value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHasShareChannel.setMessageHandler(nil)
    }
    let setClosePositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setClosePosition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setClosePositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let positionArg = args[0] as! Position
        do {
          try api.setClosePosition(position: positionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setClosePositionChannel.setMessageHandler(nil)
    }
    let setTimerGradientEnableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradientEnable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTimerGradientEnableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let isEnabledArg = args[0] as! Bool
        do {
          try api.setTimerGradientEnable(isEnabled: isEnabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTimerGradientEnableChannel.setMessageHandler(nil)
    }
    let getTimerGradientEnableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.getTimerGradientEnable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTimerGradientEnableChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTimerGradientEnable()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTimerGradientEnableChannel.setMessageHandler(nil)
    }
    let setTimerGradientChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setTimerGradient\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTimerGradientChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let colorsArg = args[0] as! [Int64]
        let locationsArg = args[1] as! [Double]
        do {
          try api.setTimerGradient(colors: colorsArg, locations: locationsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTimerGradientChannel.setMessageHandler(nil)
    }
    let setReaderBackgroundColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderBackgroundColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setReaderBackgroundColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let colorArg = args[0] as! Int64
        do {
          try api.setReaderBackgroundColor(color: colorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setReaderBackgroundColorChannel.setMessageHandler(nil)
    }
    let setReaderCornerRadiusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.AppearanceManagerHostApi.setReaderCornerRadius\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setReaderCornerRadiusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let radiusArg = args[0] as! Int64
        do {
          try api.setReaderCornerRadius(radius: radiusArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setReaderCornerRadiusChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASSingleStoryHostApi {
  func showOnce(storyId: String) throws
  func show(storyId: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASSingleStoryHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASSingleStoryHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASSingleStoryHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let showOnceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.showOnce\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showOnceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! String
        do {
          try api.showOnce(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showOnceChannel.setMessageHandler(nil)
    }
    let showChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASSingleStoryHostApi.show\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let storyIdArg = args[0] as! String
        do {
          try api.show(storyId: storyIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol IShowStoryOnceCallbackFlutterApiProtocol {
  func onShow(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onError(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func alreadyShown(completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class IShowStoryOnceCallbackFlutterApi: IShowStoryOnceCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onShow(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.onShow\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onError(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.onError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func alreadyShown(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.IShowStoryOnceCallbackFlutterApi.alreadyShown\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol SingleLoadCallbackFlutterApiProtocol {
  func singleLoad(storyData storyDataArg: StoryDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class SingleLoadCallbackFlutterApi: SingleLoadCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func singleLoad(storyData storyDataArg: StoryDataDto, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.SingleLoadCallbackFlutterApi.singleLoad\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([storyDataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IASOnboardingsHostApi {
  /// [feed] by default == "onboarding"
  /// [limit] has to be set greater than 0 (can be set as any big number if limits is unnecessary)
  func show(limit: Int64, feed: String, tags: [String]) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IASOnboardingsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonGeneratedPigeonCodec.shared }
  /// Sets up an instance of `IASOnboardingsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IASOnboardingsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// [feed] by default == "onboarding"
    /// [limit] has to be set greater than 0 (can be set as any big number if limits is unnecessary)
    let showChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.inappstory_plugin.IASOnboardingsHostApi.show\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let limitArg = args[0] as! Int64
        let feedArg = args[1] as! String
        let tagsArg = args[2] as! [String]
        do {
          try api.show(limit: limitArg, feed: feedArg, tags: tagsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      showChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnboardingLoadCallbackFlutterApiProtocol {
  func onboardingLoad(count countArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class OnboardingLoadCallbackFlutterApi: OnboardingLoadCallbackFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonGeneratedPigeonCodec {
    return PigeonGeneratedPigeonCodec.shared
  }
  func onboardingLoad(count countArg: Int64, feed feedArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.inappstory_plugin.OnboardingLoadCallbackFlutterApi.onboardingLoad\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([countArg, feedArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
